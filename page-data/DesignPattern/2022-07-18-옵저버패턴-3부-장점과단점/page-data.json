{"componentChunkName":"component---src-templates-blog-post-js","path":"/DesignPattern/2022-07-18-옵저버패턴-3부-장점과단점/","result":{"data":{"site":{"siteMetadata":{"title":"3DPIT Study Blog","author":"[KyeongMinPark]","siteUrl":"https://3dpit.github.io","comment":{"disqusShortName":"","utterances":"3dpit/3dpit.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"e34be7a6-ccf2-51a5-8fd3-2552c64f23fc","excerpt":"2022-07-18-옵저버패턴-3부-장점과단점 목차  01.옵저버패턴의 장단점  01.1 장점  01.2 단점 01.옵저버패턴의 장단점 다수의 객체가 특정 객체 상태 변화를 감지하고 알림을 받는 패턴 01.1 장점 상태를 변경하는 객체 (publisher)와 변경을 감지하는 객체(subscriber)의 관계를 느슨하게 유지할 수 있음 Subject 상태변경을 주기적으로 감지하지 않더라도 데이터를 받아옴 런타임 주기에 옵저버를 등록,해제 할 수 있다는 장점이 있음 01.…","html":"<h2 id=\"2022-07-18-옵저버패턴-3부-장점과단점\" style=\"position:relative;\"><a href=\"#2022-07-18-%EC%98%B5%EC%A0%80%EB%B2%84%ED%8C%A8%ED%84%B4-3%EB%B6%80-%EC%9E%A5%EC%A0%90%EA%B3%BC%EB%8B%A8%EC%A0%90\" aria-label=\"2022 07 18 옵저버패턴 3부 장점과단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2022-07-18-옵저버패턴-3부-장점과단점</h2>\n<h2 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h2>\n<blockquote>\n<p> 01.옵저버패턴의 장단점</p>\n<blockquote>\n<p> 01.1 장점</p>\n<p> 01.2 단점</p>\n</blockquote>\n</blockquote>\n<h2 id=\"01옵저버패턴의-장단점\" style=\"position:relative;\"><a href=\"#01%EC%98%B5%EC%A0%80%EB%B2%84%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"01옵저버패턴의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>01.옵저버패턴의 장단점</h2>\n<ul>\n<li>다수의 객체가 특정 객체 상태 변화를 감지하고 알림을 받는 패턴</li>\n</ul>\n<h3 id=\"011-장점\" style=\"position:relative;\"><a href=\"#011-%EC%9E%A5%EC%A0%90\" aria-label=\"011 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>01.1 장점</h3>\n<ul>\n<li>상태를 변경하는 객체 (publisher)와 변경을 감지하는 객체(subscriber)의 관계를 느슨하게 유지할 수 있음</li>\n<li>Subject 상태변경을 주기적으로 감지하지 않더라도 데이터를 받아옴</li>\n<li>런타임 주기에 옵저버를 등록,해제 할 수 있다는 장점이 있음</li>\n</ul>\n<h3 id=\"012-단점\" style=\"position:relative;\"><a href=\"#012-%EB%8B%A8%EC%A0%90\" aria-label=\"012 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>01.2 단점</h3>\n<ul>\n<li>복잡도가 증가함</li>\n<li>\n<p>오브젝트 등록하고 해제하는 과정 필요</p>\n<ul>\n<li>등록되어 있는 오브젝트가 등록안하고 해지 안하면 쌓이는데</li>\n<li>\n<p>계속 가지고 있어서 가비지컬렉터의 대상이 되지 않음</p>\n<ul>\n<li>맵에 담아놔서 다른곳에서 쓰지 않아도 맵에 담겨있다는 것만으로도 대상이 안되는것</li>\n<li>그래서 메모리 누수 현상이 발생하게됨</li>\n<li>대안으로 unregister해주거나 하는것이 가장 좋은 방법이지만 </li>\n<li>특정상황에서 다른곳에서 참조하지 않으면 자동으로 레퍼런스 해제할 수 있도록 할 수 있음</li>\n<li>\n<p>weakReference라는게 있는데 이를 이용해서 사용하면됨 (주로 해시맵에 적용함)</p>\n<ul>\n<li>완전한 해결방법은 아니다. 해지를 명시적으로 할 수 없거나 레퍼런스 사라져도 상관없는 경우 사용함</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"옵저버패턴 3부 장점과단점","date":"July 18, 2022"}}},"pageContext":{"slug":"/DesignPattern/2022-07-18-옵저버패턴-3부-장점과단점/","previous":{"fields":{"slug":"/DesignPattern/2022-07-18-옵저버패턴-2부-패턴적용하기/"},"frontmatter":{"title":"옵저버패턴 2부 패턴적용하기"}},"next":{"fields":{"slug":"/Algorithm/2022-07-23-카카오-[3차]압축/"},"frontmatter":{"title":"카카오-[3차]압축"}}}},"staticQueryHashes":["2486386679","3128451518"]}