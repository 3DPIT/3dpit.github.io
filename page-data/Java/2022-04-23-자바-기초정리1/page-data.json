{"componentChunkName":"component---src-templates-blog-post-js","path":"/Java/2022-04-23-자바-기초정리1/","result":{"data":{"site":{"siteMetadata":{"title":"3DPIT Study Blog","author":"[KyeongMinPark]","siteUrl":"https://3dpit.github.io","comment":{"disqusShortName":"","utterances":"3dpit/3dpit.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"26291ef8-cc70-5f97-8bb0-cd8e4bc99602","excerpt":"2022-04-23-자바-기초정리1 목차 01.객체와 클래스 차이점 02.자바 기본형과 Wrapper 클래스 차이점 03.자바 컬렉션 종류와 차이점 04.Equals VS == 연산자 차이점 05.추상화란? 06.추상 클래스란? 06.1추상 클래스의 용도 07.인터페이스란? 08.추상클래스 VS 인터페이스 차이점 09.String, StringBuffer, StringBuilder 차이점과 장단점 String StringBuffer와 String Builder 0…","html":"<h2 id=\"2022-04-23-자바-기초정리1\" style=\"position:relative;\"><a href=\"#2022-04-23-%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88%EC%A0%95%EB%A6%AC1\" aria-label=\"2022 04 23 자바 기초정리1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2022-04-23-자바-기초정리1</h2>\n<h2 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h2>\n<blockquote>\n<p>01.객체와 클래스 차이점</p>\n<p>02.자바 기본형과 Wrapper 클래스 차이점</p>\n<p>03.자바 컬렉션 종류와 차이점</p>\n<p>04.Equals VS == 연산자 차이점</p>\n<p>05.추상화란?</p>\n<p>06.추상 클래스란?</p>\n<blockquote>\n<p>06.1추상 클래스의 용도</p>\n</blockquote>\n<p>07.인터페이스란?</p>\n<p>08.추상클래스 VS 인터페이스 차이점</p>\n<p>09.String, StringBuffer, StringBuilder 차이점과 장단점</p>\n<blockquote>\n<p><strong>String</strong></p>\n<p>StringBuffer와 String Builder</p>\n</blockquote>\n</blockquote>\n<h2 id=\"01객체와-클래스-차이점\" style=\"position:relative;\"><a href=\"#01%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"01객체와 클래스 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>01.객체와 클래스 차이점</h2>\n<ul>\n<li>\n<p>클래스는 객체를 생성하기 위한 설계도 또는 툴</p>\n<ul>\n<li>붕어빵 툴</li>\n</ul>\n</li>\n<li>\n<p>객체는 설계도 또는 툴로 찍어낸 실체</p>\n<ul>\n<li>붕어빵</li>\n</ul>\n</li>\n<li>\n<p>객체를 클래스의 인스턴스라고 부름</p>\n<ul>\n<li>객체와 인스턴스 두 용어 구분 없이 사용</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"02-자바-기본형과-wrapper-클래스-차이점\" style=\"position:relative;\"><a href=\"#02-%EC%9E%90%EB%B0%94-%EA%B8%B0%EB%B3%B8%ED%98%95%EA%B3%BC-wrapper-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"02 자바 기본형과 wrapper 클래스 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>02. 자바 기본형과 Wrapper 클래스 차이점</h2>\n<ul>\n<li>\n<p>Wrapper 클래스</p>\n<ul>\n<li>8개의 기본 데이터를 객체 형식으로 다루기 위해 JDK에 의해 지원되는 8개의 클래스</li>\n<li>Byte, Short, Integer, Long, charater, Double, Float, Boolean을 통칭함</li>\n<li>int, double등 자바 기본 데이터 타입은 클래스가 아님, 따라서 데이터 값도 객체가 아님</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"03자바-컬렉션-종류와-차이점\" style=\"position:relative;\"><a href=\"#03%EC%9E%90%EB%B0%94-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%A2%85%EB%A5%98%EC%99%80-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"03자바 컬렉션 종류와 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>03.자바 컬렉션 종류와 차이점</h2>\n<ul>\n<li>Set : 중복 허용안함, 순서 유지 안함</li>\n<li>\n<p>List: 중복 허용, 순서 유지</p>\n<ul>\n<li>컬렉션은 가변 크기로써 객체의 개수를 염려할 필요 없음</li>\n<li>컬렉션 내의 한 객체가 삭제되면 컬렉션이 자동으로 자리를 옮겨줌</li>\n</ul>\n</li>\n<li>\n<p>Vector: List 인터페이스를 구현한 클래스</p>\n<ul>\n<li>가변개수의 배열이 필요할 때 적합</li>\n<li>백터에 삽입되는 요소의 수가 많아지면 자동으로 크기가 조절됨</li>\n<li>요소는 백터의 맨 마지막이나 중간에 삽입 가능</li>\n<li>무조건 동기화</li>\n<li>\n<p>성능이 많이 떨어짐, 쓸일이 별로 없어짐</p>\n<ul>\n<li>그이유는 동기화 처리가 필요할 때 (Collection, SynchronizedCollection, SynchronizedList, Map등을 이용하는게 성능적으로 더 좋음)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>ArrayList: Vector클래스와 거의 동일</p>\n<ul>\n<li>크게 다른 점은 ArrayList는 쓰레드 간에 동기화를 지원하지 않음</li>\n<li>다수의 쓰레드가 동시에 요소를 삽입하거나 삭제 시 충돌 발생</li>\n<li>ArrayList를 이용하려면 멀티 쓰레드의 동기화를 직접 구현해야함</li>\n</ul>\n</li>\n<li>HashMap&#x3C;K,V> : 키, 값의 쌍으로 구성되는 요소를 다룸</li>\n<li>\n<p>LikedList: List인터페이스를 구현한 클래스</p>\n<ul>\n<li>요소들을 양방향으로 연결하여 관리한다는 점을 제외하고, Vector, ArrayList와 유사</li>\n<li>LinkedList는 맨앞과 맨 뒤, 중간에 요소의 삽입이 가능하며, 인덱스를 이용하여 요소에 접근할 수 도 있음</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"04equals-vs--연산자-차이점\" style=\"position:relative;\"><a href=\"#04equals-vs--%EC%97%B0%EC%82%B0%EC%9E%90-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"04equals vs  연산자 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>04.Equals VS == 연산자 차이점</h2>\n<ul>\n<li>Equals: 문자열 자체를 비교</li>\n<li>\n<p>== 연산자: 객체의 주소값을 비교</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> s1 <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> s2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ns1 <span class=\"token operator\">==</span> s2<span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>위의 결과는 어떻게 될까?</li>\n<li>false를 출력한다.</li>\n<li>String s1 = “abc”는 String Pool에서 관리</li>\n<li>따라서,  두 개의 문자열 변수를 지정했지만 JVM Heap 메모리의 String Pool에는 “abc”라는 문자열 하나만 존재</li>\n<li>new 키워드를 사용한 두 번째 문장은, Heap에 객체를 생성하게 됨</li>\n<li>같은 객체를 참조하는 것이 아니기 때문에 결과는 false</li>\n<li>== 연산자는 객체의 주소 값을 비교</li>\n<li>true로 만들기 위해서는 어떻게 ?</li>\n<li>s1.equals(s2); 해서 문자열 자체를 비교하거나</li>\n<li>s2.intern()메서드를 이용하여 String Pool에 등록해서 비교하면됨</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"05추상화란\" style=\"position:relative;\"><a href=\"#05%EC%B6%94%EC%83%81%ED%99%94%EB%9E%80\" aria-label=\"05추상화란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>05.추상화란?</h2>\n<ul>\n<li>어떤 객체를 표현함에 있어서 모든 것을 다 표현하는 것이 아니라 일정 부분 특징만을 표현</li>\n<li>\n<p>추상화를 하게 되면 목적을 위해 필요한 부분만을 찾을 수 있음</p>\n<ul>\n<li>공통된 개념과 관계에 집중할 수 있게됨</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"06추상-클래스란\" style=\"position:relative;\"><a href=\"#06%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%9E%80\" aria-label=\"06추상 클래스란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>06.추상 클래스란?</h2>\n<ul>\n<li>\n<p>추상 메소드 를 포함하는 클래스</p>\n<ul>\n<li>추상메소드 : 선언은 되어 있으나 코드 구현 이 안되어있고, 껍데기만 있는것</li>\n<li>abstract로 선언</li>\n</ul>\n</li>\n<li>추상 메소드가 하나도 없지만 abstract로 선언한 클래스</li>\n</ul>\n<h3 id=\"061추상-클래스의-용도\" style=\"position:relative;\"><a href=\"#061%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%9A%A9%EB%8F%84\" aria-label=\"061추상 클래스의 용도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>06.1추상 클래스의 용도</h3>\n<ul>\n<li>\n<p>추상 클래스를 상속받은 서브클래스는 개발자에 따라 다양하게 구현</p>\n<ul>\n<li>하지만 모든 개발자들은 서브 클래스에서 추상 클래스에 선언된 추상 메소드를 모두 구현해야함</li>\n</ul>\n</li>\n<li>\n<p>추상 클래스를 책의 목차로 비유하면, </p>\n<ul>\n<li>서브 클래스는  목차에 따라 작성된 실제 책</li>\n<li>여기서 목차는 추상 클래스</li>\n</ul>\n</li>\n<li>추상 클래스를 이용하면 응용프로그램의 설계와 구현을 분리할 수 있음</li>\n<li>\n<p>추상 클래스로 기본 방향을 잡아놓고 서브 클래스에서 구현하면 구현 작업이 쉬워짐</p>\n<ul>\n<li>또한 추상 클래스는 계층적 상속 관계를 가지는 클래스들의 구조를 만들 때 적합</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"07인터페이스란\" style=\"position:relative;\"><a href=\"#07%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%9E%80\" aria-label=\"07인터페이스란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>07.인터페이스란?</h2>\n<ul>\n<li>자바의 인터페이스는 추상클래스와 유사</li>\n<li>\n<p>인터페이스는 규격과 같은것 </p>\n<ul>\n<li>따라서 인터페이스에 수정을 가할 때는 기존 인터페이스를 상속받아 새로운 인터페이스를 만듦</li>\n<li>자바에서 클래스의 다중 상속은 안됨, 인터페이스 다중 상속 가능</li>\n</ul>\n</li>\n<li>멤버는 추상 메소드(public abstract), 상수(public static final)만으로 구성</li>\n<li>모든 메소드는 public이면 생략 가능</li>\n<li>객체 생성 안됨</li>\n<li>다른 인터페이스 상속 가능(인터페이스는 다른 인터페이스를 상속 할 수 있음)</li>\n<li>\n<p>인터페이스 구현 :</p>\n<ul>\n<li>인터페이스의 추상 메소드를 클래스에 구현하는 것 (implements 키워드)</li>\n<li>이때, 클래스는 반드시 인터페이스의 모든 추상 메소드를 구현해야 함</li>\n</ul>\n</li>\n<li>\n<p>인터페이스 사용하는 이유? :</p>\n<ul>\n<li>사용될 클래스가 어떠한 메소드, 멤버들을 갖고 있는가에 대한 명세서와 같은 역할</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"08추상클래스-vs-인터페이스-차이점\" style=\"position:relative;\"><a href=\"#08%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"08추상클래스 vs 인터페이스 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>08.추상클래스 VS 인터페이스 차이점</h2>\n<table>\n<thead>\n<tr>\n<th>추상 클래스</th>\n<th>인터페이스</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>일반 메소드 포함 가능</td>\n<td>모든 메소드가 추상 메소드</td>\n</tr>\n<tr>\n<td>상수 필드만 포함 가능</td>\n<td>상수, 변수 필드 포함 가능</td>\n</tr>\n<tr>\n<td>모든 서브 클래스에 공통된 메소드가 있는 경우에는 추상 클래스가 적합</td>\n<td>다중 상속 지원</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"09string-stringbuffer-stringbuilder-차이점과-장단점\" style=\"position:relative;\"><a href=\"#09string-stringbuffer-stringbuilder-%EC%B0%A8%EC%9D%B4%EC%A0%90%EA%B3%BC-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"09string stringbuffer stringbuilder 차이점과 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>09.String, StringBuffer, StringBuilder 차이점과 장단점</h2>\n<h3 id=\"string\" style=\"position:relative;\"><a href=\"#string\" aria-label=\"string permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>String</strong></h3>\n<ul>\n<li>immutable(불변)</li>\n<li>문자열을 조작하는 경우 유용하게 사용할 수 있음</li>\n<li>\n<p>문자열, 숫자, char등은 concat시 stringBuffer, stringBuilder를 사용할 수 있음</p>\n<ul>\n<li>단, 복잡한 경우 의미가 있음</li>\n</ul>\n</li>\n<li>단순한 경우 굳이 StringBuffer, StringBuilder를 쓰지 않고 +연산자를 활용해 직접 합치면됨</li>\n<li>\n<p>Stirng 객체는 한번 생성되면 할당된 메모리 공간이 변하지 않음</p>\n<ul>\n<li>+연산자 또는 concat매서드를 통해 기존에 생성된 String 클래스 객체 문자열에 다른 문자열 붙이면</li>\n<li>기존 문자열에 새로운 문자열 붙이는것 아님</li>\n<li>\n<p>새로운 String객체를 만든 후, 새 String 객체에 연결된 문자열을 저장하고, 그 객체를 참조</p>\n<ul>\n<li>(즉, Stirng 클래스 객체는 Heap메모리 영역에 생성)</li>\n<li>한번 생성된 객체의 내부 내용을 변화시킬 수 없음</li>\n<li>기존 객체가 제거되면 java의 가비지 컬렉션이 회수</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>그래서, 문자열 연산이 많은 경우 성능이 좋지 않음</li>\n<li>immutable한 객체의 경우 간단하게 사용가능하고, 동기화에 신경 않아도 되기때문에\n내부 데이터를 자유롭게 공유 가능</li>\n</ul>\n<h3 id=\"stringbuffer와-string-builder\" style=\"position:relative;\"><a href=\"#stringbuffer%EC%99%80-string-builder\" aria-label=\"stringbuffer와 string builder permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>StringBuffer와 String Builder</strong></h3>\n<ul>\n<li>mutable(변함)</li>\n<li>문자열 연산 등으로 기존 객체의 공간이 부족하게 되는 경우, 기존의 버퍼 크기를 늘리면 유연하게 동작</li>\n<li>\n<p>StringBuffer와 StringBuilder의 차이 </p>\n<ul>\n<li>동기화 여부 </li>\n<li>StringBuffer는 각 메서드별로 Synchronized Keyword가 존재하여,\n멀티스레드 환경에서도 동기화를 지원</li>\n<li>멀티스레드 환경에서 좋음</li>\n<li>StringBuilder는 동기화를 보장하지 않음</li>\n<li>단일 스레드 환경에서 좋음</li>\n</ul>\n</li>\n<li>\n<p>정리</p>\n<ul>\n<li>String : 짧은 문자열을 더할 경우 사용</li>\n<li>StringBuffer : 스레드에 안전한 프로그램이 필요하거나,\n개발중인 시스템의 부분이 스레드에 안전한지 모를 경우 사용하면 좋음</li>\n<li>StringBuilder : 스레드에 안전한지 여부에 전혀 관계없는 프로그램을 개발할 때 사용하면 좋음</li>\n</ul>\n</li>\n<li>\n<p><strong>성능만 따지고 본 경우</strong></p>\n<ul>\n<li>StringBuilder > StringBuffer >>> String</li>\n</ul>\n</li>\n<li>\n<p><strong>stringBuffer vs String</strong></p>\n<ul>\n<li>stringBuffer는 Mutable</li>\n</ul>\n</li>\n<li><strong>String Pool이 위치하는 영역은?</strong></li>\n<li>\n<p>Heap 영역</p>\n<ul>\n<li>Perm 영역에서 JAVA7에서 Heap으로 바뀜</li>\n<li>이점 : string pool의 모든 문자열도 GC의 대상이 될 수 있음</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"자바 기초정리1","date":"April 23, 2022"}}},"pageContext":{"slug":"/Java/2022-04-23-자바-기초정리1/","previous":{"fields":{"slug":"/Java/2022-04-23-자바의-메모리-모델과-Object-클래스/"},"frontmatter":{"title":"자바의 메모리 모델과 Object 클래스"}},"next":{"fields":{"slug":"/Docker/2022-04-26-grafana-dashboard-유지-및-에러-문제-해결/"},"frontmatter":{"title":"Grafana Dashboard 유지 및 에러 문제 해결"}}}},"staticQueryHashes":["2486386679","3128451518"]}