---
title: 자바 기초정리1
date: 2022-04-23 21:40:00 +0900
category: Java
draft: false
---

## 2022-04-23-자바-기초정리1

## 목차

> 01.객체와 클래스 차이점
>
> 02.자바 기본형과 Wrapper 클래스 차이점
>
> 03.자바 컬렉션 종류와 차이점
>
> 04.Equals VS == 연산자 차이점
>
> 05.추상화란?
>
> 06.추상 클래스란?
>
> > 06.1추상 클래스의 용도
>
> 07.인터페이스란?
>
> 08.추상클래스 VS 인터페이스 차이점
>
> 09.String, StringBuffer, StringBuilder 차이점과 장단점
>
> > String
> >
> > StringBuffer와 String Builder

## 01.객체와 클래스 차이점

- 클래스는 객체를 생성하기 위한 설계도 또는 툴
  - 붕어빵 툴
- 객체는 설계도 또는 툴로 찍어낸 실체
  - 붕어빵
- 객체를 클래스의 인스턴스라고 부름
  - 객체와 인스턴스 두 용어 구분 없이 사용

## 02. 자바 기본형과 Wrapper 클래스 차이점

- Wrapper 클래스
  - 8개의 기본 데이터를 객체 형식으로 다루기 위해 JDK에 의해 지원되는 8개의 클래스
    - Byte, Short, Integer, Long, charater, Double, Float, Boolean을 통칭함
  - int, double등 자바 기본 데이터 타입은 클래스가 아님, 따라서 데이터 값도 객체가 아님

## 03.자바 컬렉션 종류와 차이점

- Set : 중복 허용안함, 순서 유지 안함
- List: 중복 허용, 순서 유지
  - 컬렉션은 가변 크기로써 객체의 개수를 염려할 필요 없음
  - 컬렉션 내의 한 객체가 삭제되면 컬렉션이 자동으로 자리를 옮겨줌
- Vector: List 인터페이스를 구현한 클래스
  - 가변개수의 배열이 필요할 때 적합
  - 백터에 삽입되는 요소의 수가 많아지면 자동으로 크기가 조절됨
  - 요소는 백터의 맨 마지막이나 중간에 삽입 가능
  - 무조건 동기화
    - 성능이 많이 떨어짐, 쓸일이 별로 없어짐
      - 그이유는 동기화 처리가 필요할 때 (Collection, SynchronizedCollection, SynchronizedList, Map등을 이용하는게 성능적으로 더 좋음)
- ArrayList: Vector클래스와 거의 동일
  - 크게 다른 점은 ArrayList는 쓰레드 간에 동기화를 지원하지 않음
    - 다수의 쓰레드가 동시에 요소를 삽입하거나 삭제 시 충돌 발생
    - ArrayList를 이용하려면 멀티 쓰레드의 동기화를 직접 구현해야함
- HashMap<K,V> : 키, 값의 쌍으로 구성되는 요소를 다룸
- LikedList: List인터페이스를 구현한 클래스
  - 요소들을 양방향으로 연결하여 관리한다는 점을 제외하고, Vector, ArrayList와 유사
  - LinkedList는 맨앞과 맨 뒤, 중간에 요소의 삽입이 가능하며, 인덱스를 이용하여 요소에 접근할 수 도 있음

## 04.Equals VS == 연산자 차이점

- Equals: 문자열 자체를 비교

- == 연산자: 객체의 주소값을 비교

  ```java
  String s1 = "abc";
  String s2 = new String("abc");
  s1 == s2;
  ```

  - 위의 결과는 어떻게 될까?
    - false를 출력한다.
  - String s1 = "abc"는 String Pool에서 관리
    - 따라서,  두 개의 문자열 변수를 지정했지만 JVM Heap 메모리의 String Pool에는 "abc"라는 문자열 하나만 존재
  - new 키워드를 사용한 두 번째 문장은, Heap에 객체를 생성하게 됨
    - 같은 객체를 참조하는 것이 아니기 때문에 결과는 false
    - == 연산자는 객체의 주소 값을 비교
  - true로 만들기 위해서는 어떻게 ?
    - s1.equals(s2); 해서 문자열 자체를 비교하거나
    - s2.intern()메서드를 이용하여 String Pool에 등록해서 비교하면됨

## 05.추상화란?

- 어떤 객체를 표현함에 있어서 모든 것을 다 표현하는 것이 아니라 일정 부분 특징만을 표현
- 추상화를 하게 되면 목적을 위해 필요한 부분만을 찾을 수 있음
  - 공통된 개념과 관계에 집중할 수 있게됨

## 06.추상 클래스란?

- 추상 메소드 를 포함하는 클래스

  - 추상메소드 : 선언은 되어 있으나 코드 구현 이 안되어있고, 껍데기만 있는것
  - abstract로 선언

- 추상 메소드가 하나도 없지만 abstract로 선언한 클래스


### 06.1추상 클래스의 용도

- 추상 클래스를 상속받은 서브클래스는 개발자에 따라 다양하게 구현
  - 하지만 모든 개발자들은 서브 클래스에서 추상 클래스에 선언된 추상 메소드를 모두 구현해야함
- 추상 클래스를 책의 목차로 비유하면, 
  - 서브 클래스는  목차에 따라 작성된 실제 책
  - 여기서 목차는 추상 클래스
- 추상 클래스를 이용하면 응용프로그램의 설계와 구현을 분리할 수 있음
- 추상 클래스로 기본 방향을 잡아놓고 서브 클래스에서 구현하면 구현 작업이 쉬워짐
  - 또한 추상 클래스는 계층적 상속 관계를 가지는 클래스들의 구조를 만들 때 적합

## 07.인터페이스란?

- 자바의 인터페이스는 추상클래스와 유사
- 인터페이스는 규격과 같은것 
  - 따라서 인터페이스에 수정을 가할 때는 기존 인터페이스를 상속받아 새로운 인터페이스를 만듦
  - 자바에서 클래스의 다중 상속은 안됨, 인터페이스 다중 상속 가능
- 멤버는 추상 메소드(public abstract), 상수(public static final)만으로 구성
- 모든 메소드는 public이면 생략 가능
- 객체 생성 안됨
- 다른 인터페이스 상속 가능(인터페이스는 다른 인터페이스를 상속 할 수 있음)
- 인터페이스 구현 :
  - 인터페이스의 추상 메소드를 클래스에 구현하는 것 (implements 키워드)
  - 이때, 클래스는 반드시 인터페이스의 모든 추상 메소드를 구현해야 함
- 인터페이스 사용하는 이유? :
  - 사용될 클래스가 어떠한 메소드, 멤버들을 갖고 있는가에 대한 명세서와 같은 역할

## 08.추상클래스 VS 인터페이스 차이점

| 추상 클래스                                                  | 인터페이스                |
| ------------------------------------------------------------ | ------------------------- |
| 일반 메소드 포함 가능                                        | 모든 메소드가 추상 메소드 |
| 상수 필드만 포함 가능                                        | 상수, 변수 필드 포함 가능 |
| 모든 서브 클래스에 공통된 메소드가 있는 경우에는 추상 클래스가 적합 | 다중 상속 지원            |


## 09.String, StringBuffer, StringBuilder 차이점과 장단점

### **String** 

- immutable(불변)
- 문자열을 조작하는 경우 유용하게 사용할 수 있음
- 문자열, 숫자, char등은 concat시 stringBuffer, stringBuilder를 사용할 수 있음
  - 단, 복잡한 경우 의미가 있음
- 단순한 경우 굳이 StringBuffer, StringBuilder를 쓰지 않고 +연산자를 활용해 직접 합치면됨
- Stirng 객체는 한번 생성되면 할당된 메모리 공간이 변하지 않음
  - +연산자 또는 concat매서드를 통해 기존에 생성된 String 클래스 객체 문자열에 다른 문자열 붙이면
    - 기존 문자열에 새로운 문자열 붙이는것 아님
    - 새로운 String객체를 만든 후, 새 String 객체에 연결된 문자열을 저장하고, 그 객체를 참조
      - (즉, Stirng 클래스 객체는 Heap메모리 영역에 생성)
      - 한번 생성된 객체의 내부 내용을 변화시킬 수 없음
      - 기존 객체가 제거되면 java의 가비지 컬렉션이 회수
- 그래서, 문자열 연산이 많은 경우 성능이 좋지 않음
- immutable한 객체의 경우 간단하게 사용가능하고, 동기화에 신경 않아도 되기때문에 
  내부 데이터를 자유롭게 공유 가능

### **StringBuffer와 String Builder**

- mutable(변함)
- 문자열 연산 등으로 기존 객체의 공간이 부족하게 되는 경우, 기존의 버퍼 크기를 늘리면 유연하게 동작
- StringBuffer와 StringBuilder의 차이 
  - 동기화 여부 
  - StringBuffer는 각 메서드별로 Synchronized Keyword가 존재하여,
    멀티스레드 환경에서도 동기화를 지원
    - 멀티스레드 환경에서 좋음
  - StringBuilder는 동기화를 보장하지 않음
    - 단일 스레드 환경에서 좋음

- 정리
  - String : 짧은 문자열을 더할 경우 사용
  - StringBuffer : 스레드에 안전한 프로그램이 필요하거나,
    개발중인 시스템의 부분이 스레드에 안전한지 모를 경우 사용하면 좋음
  - StringBuilder : 스레드에 안전한지 여부에 전혀 관계없는 프로그램을 개발할 때 사용하면 좋음
- **성능만 따지고 본 경우**
  - StringBuilder > StringBuffer >>> String

- **stringBuffer vs String**

  - stringBuffer는 Mutable

- **String Pool이 위치하는 영역은?**
- Heap 영역
  - Perm 영역에서 JAVA7에서 Heap으로 바뀜
    - 이점 : string pool의 모든 문자열도 GC의 대상이 될 수 있음